package app;

import java.util.ArrayList;
import java.util.List;

import org.opencv.core.*;
import org.opencv.imgproc.*;


/**
* GripPipelineSimilar class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipelineSimilar {
	//Outputs
	private Mat convertOutput = new Mat();
	private Mat cvResize0Output = new Mat();
	private Mat blurOutput = new Mat();
	private Mat splitOutput = new Mat();
	private Mat normalizeOutput = new Mat();
	private Mat equalizeOutput = new Mat();
	private Mat cvResize1Output = new Mat();
	private Mat cvAdaptivethresholdOutput = new Mat();

	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(Mat source0, int channelSelected) {
		// Step Convert B&W to color so all are like color
		if (source0.channels() <= 2) {        
			convert(source0, source0, Imgproc.COLOR_GRAY2BGR);
		}
		// Step Convert0:
		Mat convertSrc = source0;
		int convertType = Imgproc.COLOR_BGR2YUV;
		//System.err.println("convert " + convertSrc);
		convert(convertSrc, convertOutput, convertType);
		// Step CV_resize0:
		Mat cvResize0Src = convertOutput;
		Size cvResize0Dsize = new Size(160, 160);
		double cvResize0Fx = 0.;
		double cvResize0Fy = 0.;
		int cvResize0Interpolation = Imgproc.INTER_LINEAR;
		// System.err.println("resize0 " + cvResize0Src);
		cvResize(cvResize0Src, cvResize0Dsize, cvResize0Fx, cvResize0Fy, cvResize0Interpolation, cvResize0Output);
		// Step Blur0:
		Mat blurInput = cvResize0Output;
		BlurType blurType = BlurType.get("Gaussian Blur");
		double blurRadius = 8.;
		// System.err.println("blur0 " + blurInput);
		blur(blurInput, blurType, blurRadius, blurOutput);

		// Step Split0:
		Mat splitInput = blurOutput;
		// System.err.println("desaturate0 " + splitInput);
		split(splitInput, splitOutput, channelSelected);

		// Step Normalize0:
		Mat normalizeInput = splitOutput;
		int normalizeType = Core.NORM_MINMAX;
		double normalizeAlpha = 0.0;
		double normalizeBeta = 255.0;
		// System.err.println("normalize0 " + normalizeInput);
		normalize(normalizeInput, normalizeType, normalizeAlpha, normalizeBeta, normalizeOutput);

		// Step Equalize0:
		Mat cvEqualizeSrc = normalizeOutput;
		// System.err.println("equalize0 " + cvEqualizeSrc);
		equalize(cvEqualizeSrc, equalizeOutput);

		// Step CV_resize1:
		Mat cvResize1Src = equalizeOutput;
		Size cvResize1Dsize = new Size(8, 8); // don't exceed 64 bits since it's stored in a long
		double cvResize1Fx = 0.;
		double cvResize1Fy = 0.;
		int cvResize1Interpolation = Imgproc.INTER_LINEAR;
		// System.err.println("cvResize1 " + cvResize1Src);
		cvResize(cvResize1Src, cvResize1Dsize, cvResize1Fx, cvResize1Fy, cvResize1Interpolation, cvResize1Output);

		// Step CV_adaptiveThreshold0:
		Mat cvAdaptivethresholdSrc = cvResize1Output;
		double cvAdaptivethresholdMaxvalue = 255.0;
		int cvAdaptivethresholdAdaptivemethod = Imgproc.ADAPTIVE_THRESH_MEAN_C;
		int cvAdaptivethresholdThresholdtype = Imgproc.THRESH_BINARY;
		double cvAdaptivethresholdBlocksize = 3.0;
		double cvAdaptivethresholdC = 0.0;
		// System.err.println("CV_adaptiveThreshold0 " + cvAdaptivethresholdSrc);
		cvAdaptivethreshold(cvAdaptivethresholdSrc, cvAdaptivethresholdMaxvalue, cvAdaptivethresholdAdaptivemethod, cvAdaptivethresholdThresholdtype, cvAdaptivethresholdBlocksize, cvAdaptivethresholdC, cvAdaptivethresholdOutput);
	}

	/**
	 * This method is a getter for the output of a Convert.
	 * @return Mat output from Convert.
	 */
	public Mat convertOutput() {
		return convertOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_resize.
	 * @return Mat output from CV_resize.
	 */
	public Mat cvResize0Output() {
		return cvResize0Output;
	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blurOutput() {
		return blurOutput;
	}

	/**
	 * This method is a getter for the otuput of Split
	 * @return
	 */
	public Mat splitOutput() {
		return splitOutput;
	}

	/**
	 * This method is a generated getter for the output of a Normalize.
	 * @return Mat output from Normalize.
	 */
	public Mat normalizeOutput() {
		return normalizeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Equalize.
	 * @return Mat output from Equalize.
	 */
	public Mat equalizeOutput() {
		return equalizeOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_resize.
	 * @return Mat output from CV_resize.
	 */
	public Mat cvResize1Output() {
		return cvResize1Output;
	}

	/**
	 * This method is a generated getter for the output of a CV_adaptiveThreshold.
	 * @return Mat output from CV_adaptiveThreshold.
	 */
	public Mat cvAdaptivethresholdOutput() {
		return cvAdaptivethresholdOutput;
	}

	/**
	 * Converts a BGR color image into YUV.
	 * @param input
	 * @param output
	 */
	private void convert(Mat input, Mat output, int convertType) {
		Imgproc.cvtColor(input, output, convertType);
	}

	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
			BILATERAL("Bilateral Filter");

		private final String label;

		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
			return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = (int)(doubleRadius + 0.5);
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}

	/**
	 * Returns the selected channel from a multi-channel mat 
	 * @param input
	 * @param output
	 * @param channelSelected channel number to return
	 */
	private void split(Mat input, Mat output, int channelSelected) {
		List<Mat> channels = new ArrayList<Mat>();
		Core.split(input, channels);
		//System.out.println(channels.get(channelSelected));
		channels.get(channelSelected).copyTo(output);
		//System.out.println(output);
	}
	
	/**
	 * Normalizes or remaps the values of pixels in an image.
	 * @param input The image on which to perform the Normalize.
	 * @param type The type of normalization.
	 * @param a The minimum value.
	 * @param b The maximum value.
	 * @param output The image in which to store the output.
	 */
	private void normalize(Mat input, int type, double a, double b, Mat output) {
		Core.normalize(input, output, a, b, type);
	}

	/**
	 * Equalizes an image.
	 * @param input The image on which to perform the Equalize.
	 * @param output The image in which to store the output.
	 */
	private void equalize(Mat input, Mat output) {
		Imgproc.equalizeHist(input, output);
	}

	/**
	 * Resizes an image.
	 * @param src The image to resize.
	 * @param dSize size to set the image.
	 * @param fx scale factor along X axis.
	 * @param fy scale factor along Y axis.
	 * @param interpolation type of interpolation to use.
	 * @param dst output image.
	 */
	private void cvResize(Mat src, Size dSize, double fx, double fy, int interpolation,
		Mat dst) {
		if (dSize==null) {
			dSize = new Size(0,0);
		}
		Imgproc.resize(src, dst, dSize, fx, fy, interpolation);
	}

	/**
	 * Applies an adaptive threshold to an array.
	 * @param src Input Image.
	 * @param maxValue Value to assign to pixels that match the condition.
	 * @param adaptiveMethod Adaptive threshold method to use.
	 * @param thresholdType Type of threshold to use.
	 * @param blockSize Size of a pixel area that is used to calculate a threshold.
	 * @param c Constant to subtract from the mean.
	 * @param dst Output of threshold.
	 */
	private void cvAdaptivethreshold(Mat src, double maxValue, int adaptiveMethod,
		int thresholdType, double blockSize, double c, Mat dst) {
		Imgproc.adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType,
			(int)blockSize, c);
	}

	public void releaseMats() {
		convertOutput.release();
		cvResize0Output.release();
		blurOutput.release();
		splitOutput.release();
		normalizeOutput.release();
		equalizeOutput.release();
		cvResize1Output.release();
		cvAdaptivethresholdOutput.release();
	}
}
